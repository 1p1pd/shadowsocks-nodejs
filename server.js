// Generated by CoffeeScript 1.3.3
(function() {
  var config, configContent, configFile, configFromArgs, encrypt, fs, inetAton, inetNtoa, k, key, net, path, port, portPassword, timeout, v;

  net = require("net");

  fs = require("fs");

  path = require("path");

  encrypt = require("./encrypt");

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  inetAton = function(ipStr) {
    var buf, i, parts;
    parts = ipStr.split(".");
    if (parts.length !== 4) {
      return null;
    } else {
      buf = new Buffer(4);
      i = 0;
      while (i < 4) {
        buf[i] = +parts[i];
        i++;
      }
      return buf;
    }
  };

  configFromArgs = require('./args').parseArgs();

  configFile = configFromArgs.config_file || path.resolve(__dirname, "config.json");

  configContent = fs.readFileSync(configFile);

  config = JSON.parse(configContent);

  for (k in configFromArgs) {
    v = configFromArgs[k];
    config[k] = v;
  }

  timeout = Math.floor(config.timeout * 1000);

  portPassword = config.port_password;

  port = config.server_port;

  key = config.password;

  if (portPassword) {
    if (port || key) {
      console.error('warning: port_password should not be used with server_port and password. server_port and password will be ignored');
    }
  } else {
    portPassword = {};
    portPassword[PORT.toString()] = KEY;
  }

  for (port in portPassword) {
    key = portPassword[port];
    (function() {
      var KEY, PORT;
      PORT = port;
      KEY = key;
      return function() {
        var decryptTable, encryptTable, server, tables;
        console.log("calculating ciphers for port " + PORT);
        tables = encrypt.getTable(KEY);
        encryptTable = tables[0];
        decryptTable = tables[1];
        server = net.createServer(function(connection) {
          var addrLen, cachedPieces, headerLength, remote, remoteAddr, remotePort, stage;
          console.log("server connected");
          console.log("concurrent connections: " + server.connections);
          stage = 0;
          headerLength = 0;
          remote = null;
          cachedPieces = [];
          addrLen = 0;
          remoteAddr = null;
          remotePort = null;
          connection.on("data", function(data) {
            var addrtype, buf;
            encrypt.encrypt(decryptTable, data);
            if (stage === 5) {
              if (!remote.write(data)) {
                connection.pause();
              }
              return;
            }
            if (stage === 0) {
              try {
                addrtype = data[0];
                if (addrtype === 3) {
                  addrLen = data[1];
                } else if (addrtype !== 1) {
                  console.warn("unsupported addrtype: " + addrtype);
                  connection.end();
                  return;
                }
                if (addrtype === 1) {
                  remoteAddr = inetNtoa(data.slice(1, 5));
                  remotePort = data.readUInt16BE(5);
                  headerLength = 7;
                } else {
                  remoteAddr = data.slice(2, 2 + addrLen).toString("binary");
                  remotePort = data.readUInt16BE(2 + addrLen);
                  headerLength = 2 + addrLen + 2;
                }
                console.log(remoteAddr);
                remote = net.connect(remotePort, remoteAddr, function() {
                  var i, piece;
                  console.log("connecting " + remoteAddr);
                  i = 0;
                  while (i < cachedPieces.length) {
                    piece = cachedPieces[i];
                    remote.write(piece);
                    i++;
                  }
                  cachedPieces = null;
                  return stage = 5;
                });
                remote.on("data", function(data) {
                  encrypt.encrypt(encryptTable, data);
                  if (!connection.write(data)) {
                    return remote.pause();
                  }
                });
                remote.on("end", function() {
                  console.log("remote disconnected");
                  console.log("concurrent connections: " + server.connections);
                  return connection.end();
                });
                remote.on("error", function() {
                  if (stage === 4) {
                    console.warn("remote connection refused");
                    connection.end();
                    return;
                  }
                  console.warn("remote error");
                  connection.end();
                  return console.log("concurrent connections: " + server.connections);
                });
                remote.on("drain", function() {
                  return connection.resume();
                });
                remote.setTimeout(timeout, function() {
                  connection.end();
                  return remote.destroy();
                });
                if (data.length > headerLength) {
                  buf = new Buffer(data.length - headerLength);
                  data.copy(buf, 0, headerLength);
                  cachedPieces.push(buf);
                  buf = null;
                }
                return stage = 4;
              } catch (e) {
                console.warn(e);
                connection.destroy();
                if (remote) {
                  return remote.destroy();
                }
              }
            } else {
              if (stage === 4) {
                return cachedPieces.push(data);
              }
            }
          });
          connection.on("end", function() {
            console.log("server disconnected");
            if (remote) {
              remote.destroy();
            }
            return console.log("concurrent connections: " + server.connections);
          });
          connection.on("error", function() {
            console.warn("server error");
            if (remote) {
              remote.destroy();
            }
            return console.log("concurrent connections: " + server.connections);
          });
          connection.on("drain", function() {
            if (remote) {
              return remote.resume();
            }
          });
          return connection.setTimeout(timeout, function() {
            if (remote) {
              remote.destroy();
            }
            return connection.destroy();
          });
        });
        server.listen(PORT, function() {
          return console.log("server listening at port " + PORT);
        });
        return server.on("error", function(e) {
          if (e.code === "EADDRINUSE") {
            return console.warn("Address in use, aborting");
          }
        });
      };
    })()();
  }

}).call(this);
