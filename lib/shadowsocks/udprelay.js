// Generated by CoffeeScript 1.6.3
(function() {
  var LRUCache, dgram, inet, inetAton, inetNtoa, net, utils;

  utils = require('./utils');

  inet = require('./inet');

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  inetAton = function(ipStr) {
    var buf, i, parts;
    parts = ipStr.split(".");
    if (parts.length !== 4) {
      return null;
    } else {
      buf = new Buffer(4);
      i = 0;
      while (i < 4) {
        buf[i] = +parts[i];
        i++;
      }
      return buf;
    }
  };

  dgram = require('dgram');

  net = require('net');

  LRUCache = (function() {
    function LRUCache(timeout, sweepInterval) {
      var sweepFun, that;
      this.timeout = timeout;
      that = this;
      sweepFun = function() {
        return that.sweep();
      };
      this.interval = setInterval(sweepFun, sweepInterval);
      this.dict = {};
    }

    LRUCache.prototype.setItem = function(key, value) {
      var cur;
      cur = process.hrtime();
      return this.dict[key] = [value, cur];
    };

    LRUCache.prototype.getItem = function(key) {
      var v;
      v = this.dict[key];
      if (v) {
        v[1] = process.hrtime();
        return v[0];
      }
      return null;
    };

    LRUCache.prototype.delItem = function(key) {
      return delete this.dict[key];
    };

    LRUCache.prototype.sweep = function() {
      var dict, diff, k, keys, swept, v, v0, _i, _len;
      utils.debug("sweeping");
      dict = this.dict;
      keys = Object.keys(dict);
      swept = 0;
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        v = dict[k];
        diff = process.hrtime(v[1]);
        if (diff[0] > this.timeout) {
          swept += 1;
          v0 = v[0];
          v0.close();
          delete dict[k];
        }
      }
      return utils.debug("" + swept + " keys swept");
    };

    return LRUCache;

  })();

  exports.createServer = function(listenAddr, listenPort, remoteAddr, remotePort, key, method, timeout, isLocal) {
    var clientKey, clients, listenIPType, server, udpTypeToListen, udpTypesToListen, _i, _len;
    udpTypesToListen = [];
    if (listenAddr === null) {
      udpTypesToListen = ['udp4', 'udp6'];
    } else {
      listenIPType = net.isIP(listenAddr);
      if (listenIPType === 6) {
        udpTypesToListen.push('udp6');
      } else {
        udpTypesToListen.push('udp4');
      }
    }
    for (_i = 0, _len = udpTypesToListen.length; _i < _len; _i++) {
      udpTypeToListen = udpTypesToListen[_i];
      server = dgram.createSocket(udpTypeToListen);
      clients = new LRUCache(timeout, 10 * 1000);
      clientKey = function(localAddr, localPort, destAddr, destPort) {
        return "" + localAddr + ":" + localPort + ":" + destAddr + ":" + destPort;
      };
      server.on("message", function(data, rinfo) {
        var addrLen, addrtype, client, clientUdpType, dataToSend, destAddr, destPort, frag, headerLength, requestHeaderOffset, sendDataOffset, serverAddr, serverPort, _ref, _ref1;
        console.error("server got: " + data + " from " + rinfo.address + ":" + rinfo.port);
        headerLength = 0;
        requestHeaderOffset = 0;
        if (isLocal) {
          requestHeaderOffset = 3;
          frag = data[2];
          utils.debug("frag:" + frag);
          if (frag !== 0) {
            utils.wran("drop a message since frag is not 0");
            return;
          }
        }
        addrtype = data[requestHeaderOffset];
        if (addrtype === 3) {
          addrLen = data[requestHeaderOffset + 1];
        } else if (addrtype !== 1 && addrtype !== 4) {
          utils.error("unsupported addrtype: " + addrtype);
          connection.destroy();
          return;
        }
        if (addrtype === 1) {
          destAddr = inetNtoa(data.slice(requestHeaderOffset + 1, requestHeaderOffset + 5));
          destPort = data.readUInt16BE(requestHeaderOffset + 5);
          headerLength = requestHeaderOffset + 7;
        } else if (addrtype === 4) {
          destAddr = inet.inet_ntop(data.slice(requestHeaderOffset + 1, requestHeaderOffset + 17));
          destPort = data.readUInt16BE(requestHeaderOffset + 17);
          headerLength = requestHeaderOffset + 19;
        } else {
          destAddr = data.slice(requestHeaderOffset + 2, requestHeaderOffset + 2 + addrLen).toString("binary");
          destPort = data.readUInt16BE(requestHeaderOffset + 2 + addrLen);
          headerLength = requestHeaderOffset + 2 + addrLen + 2;
        }
        if (isLocal) {
          sendDataOffset = requestHeaderOffset;
          _ref = [remoteAddr, remotePort], serverAddr = _ref[0], serverPort = _ref[1];
        } else {
          sendDataOffset = headerLength;
          _ref1 = [destAddr, destPort], serverAddr = _ref1[0], serverPort = _ref1[1];
        }
        key = clientKey(rinfo.address, rinfo.port, destAddr, destPort);
        client = clients.getItem(key);
        if (client == null) {
          clientUdpType = net.isIP(serverAddr);
          if (clientUdpType === 6) {
            client = dgram.createSocket("udp6");
          } else {
            client = dgram.createSocket("udp4");
          }
          clients.setItem(key, client);
          client.on("message", function(data1, rinfo1) {
            var data2, responseHeader, serverIPBuf;
            utils.debug("client got " + data1 + " from " + rinfo1.address + ":" + rinfo1.port);
            if (!isLocal) {
              serverIPBuf = inetAton(rinfo1.address);
              responseHeader = new Buffer(7);
              responseHeader.write('\x01', 0);
              serverIPBuf.copy(responseHeader, 1, 0, 4);
              responseHeader.writeUInt16BE(rinfo1.port, 5);
              data2 = Buffer.concat([responseHeader, data1]);
            } else {
              responseHeader = new Buffer("\x00\x00\x00");
              data2 = Buffer.concat([responseHeader, data1]);
            }
            return server.send(data2, 0, data2.length, rinfo.port, rinfo.address, function(err, bytes) {
              return utils.debug("remote to local sent");
            });
          });
          client.on("error", function(err) {
            return utils.debug("error: " + err);
          });
          client.on("close", function() {
            utils.debug("close");
            return clients.delItem(key);
          });
        }
        utils.debug("pairs: " + (Object.keys(clients.dict).length));
        dataToSend = data.slice(sendDataOffset, data.length);
        utils.debug("UDP send to " + serverAddr + ":" + serverPort);
        return client.send(dataToSend, 0, dataToSend.length, serverPort, serverAddr, function(err, bytes) {
          return utils.debug("local to remote sent");
        });
      });
      server.on("listening", function() {
        var address;
        address = server.address();
        return console.error("server listening " + address.address + ":" + address.port);
      });
      if (remoteAddr) {
        server.bind(listenPort, remoteAddr);
      } else {
        server.bind(listenPort);
      }
      return server;
    }
  };

}).call(this);
