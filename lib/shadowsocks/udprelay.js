// Generated by CoffeeScript 1.6.3
(function() {
  var LRUCache, dgram, inetNtoa, net, utils;

  utils = require('./utils');

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  dgram = require('dgram');

  net = require('net');

  LRUCache = (function() {
    function LRUCache(timeout, sweepInterval) {
      var sweepFun, that;
      this.timeout = timeout;
      that = this;
      sweepFun = function() {
        return that.sweep();
      };
      this.interval = setInterval(sweepFun, sweepInterval);
      this.dict = {};
    }

    LRUCache.prototype.setItem = function(key, value) {
      var cur;
      cur = process.hrtime();
      return this.dict[key] = [value, cur];
    };

    LRUCache.prototype.getItem = function(key) {
      var v;
      v = this.dict[key];
      if (v) {
        v[1] = process.hrtime();
        return v[0];
      }
      return null;
    };

    LRUCache.prototype.delItem = function(key) {
      return delete this.dict[key];
    };

    LRUCache.prototype.sweep = function() {
      var dict, diff, k, keys, swept, v, v0, _i, _len;
      utils.debug("sweeping");
      dict = this.dict;
      keys = Object.keys(dict);
      swept = 0;
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        v = dict[k];
        diff = process.hrtime(v[1]);
        if (diff[0] > this.timeout) {
          swept += 1;
          v0 = v[0];
          v0.close();
          delete dict[k];
        }
      }
      return utils.debug("" + swept + " keys swept");
    };

    return LRUCache;

  })();

  exports.createServer = function(listenAddr, listenPort, remoteAddr, remotePort, key, method, timeout, isLocal) {
    var clientKey, clients, listenIPType, server, udpTypeToListen, udpTypesToListen, _i, _len;
    udpTypesToListen = [];
    if (listenAddr === null) {
      udpTypesToListen = ['udp4', 'udp6'];
    } else {
      listenIPType = net.isIP(listenAddr);
      if (listenIPType === 6) {
        udpTypesToListen.push('udp6');
      } else {
        udpTypesToListen.push('udp4');
      }
    }
    for (_i = 0, _len = udpTypesToListen.length; _i < _len; _i++) {
      udpTypeToListen = udpTypesToListen[_i];
      server = dgram.createSocket(udpTypeToListen);
      clients = new LRUCache(timeout, 10 * 1000);
      clientKey = function(localAddr, localPort, destAddr, destPort) {
        return "" + localAddr + ":" + localPort + ":" + destAddr + ":" + destPort;
      };
      server.on("message", function(data, rinfo) {
        var addrLen, addrtype, client, destAddr, destPort, frag, headerLength, ipType;
        console.error("server got: " + data + " from " + rinfo.address + ":" + rinfo.port);
        frag = data[2];
        utils.debug("frag:" + frag);
        if (frag !== 0) {
          utils.wran("drop a message since frag is not 0");
          return;
        }
        addrtype = data[3];
        if (addrtype === 3) {
          addrLen = data[4];
        } else if (addrtype !== 1 && addrtype !== 4) {
          utils.error("unsupported addrtype: " + addrtype);
          connection.destroy();
          return;
        }
        if (addrtype === 1) {
          destAddr = inetNtoa(data.slice(4, 8));
          destPort = data.readUInt16BE(8);
          headerLength = 10;
        } else if (addrtype === 4) {
          destAddr = inet.inet_ntop(data.slice(4, 20));
          destPort = data.readUInt16BE(20);
          headerLength = 22;
        } else {
          destAddr = data.slice(5, 5 + addrLen).toString("binary");
          destAddr = data.readUInt16BE(5 + addrLen);
          headerLength = 5 + addrLen + 2;
        }
        utils.debug("UDP send to " + destAddr + ":" + destPort);
        key = clientKey(rinfo.address, rinfo.port, destAddr, destPort);
        client = clients.getItem(key);
        if (client == null) {
          ipType = net.isIP(destAddr);
          if (ipType === 6) {
            client = dgram.createSocket("udp6");
          } else {
            client = dgram.createSocket("udp4");
          }
          clients.setItem(key, client);
          client.on("message", function(data1, rinfo1) {
            var data2;
            utils.debug("client got " + data1 + " from " + rinfo1.address + ":" + rinfo1.port);
            data2 = Buffer.concat([data.slice(0, headerLength), data1]);
            return server.send(data2, 0, data2.length, rinfo.port, rinfo.address, function(err, bytes) {
              return utils.debug("remote to client sent");
            });
          });
          client.on("error", function(err) {
            return utils.debug("error: " + err);
          });
          client.on("close", function() {
            utils.debug("close");
            return clients.delItem(key);
          });
        }
        utils.debug("pairs: " + (Object.keys(clients.dict).length));
        return client.send(data, headerLength, data.length - headerLength, destPort, destAddr, function(err, bytes) {
          return utils.debug("client to remote sent");
        });
      });
      server.on("listening", function() {
        var address;
        address = server.address();
        return console.error("server listening " + address.address + ":" + address.port);
      });
      if (remoteAddr) {
        server.bind(listenPort, remoteAddr);
      } else {
        server.bind(listenPort);
      }
      return server;
    }
  };

}).call(this);
